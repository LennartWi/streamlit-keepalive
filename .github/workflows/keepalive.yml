name: keep-streamlit-awake-browser

on:
  schedule:
    - cron: "7,37 * * * *"   # alle 30 Minuten mit Versatz
  workflow_dispatch:

jobs:
  wake:
    runs-on: ubuntu-latest
    steps:
      - name: Install Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Playwright
        run: |
          npm init -y
          npm install playwright@1
          npx playwright install --with-deps chromium

      - name: Create wake script
        run: |
          cat > wake.mjs << 'EOF'
          import { chromium } from "playwright";

          const urls = [
            "https://solarspitzengesetz-rechner.streamlit.app",
            "https://evo-rechner.streamlit.app",
            "https://atnnschwellenrechnersimpel.streamlit.app",
            "https://pv-profil-generator.streamlit.app",
            "https://schwellenwert-rechner-atypische-netznutzung.streamlit.app",
            "https://temperatur-stunden.streamlit.app",
            "https://wandlermesser.streamlit.app"
          ];

          const ua = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Safari/605.1.15";
          const pageTimeout = 45000;

          const run = async () => {
            const browser = await chromium.launch({
              headless: true,
              args: ["--no-sandbox","--disable-dev-shm-usage"]
            });
            const context = await browser.newContext({
              userAgent: ua,
              viewport: { width: 1366, height: 850 },
              javaScriptEnabled: true
            });

            for (const base of urls) {
              const page = await context.newPage();
              const url = `${base}/?embed=true&keepalive=${Date.now()}`;
              console.log(`Wake ${base}`);

              try {
                // Seite laden bis Netz ruhig
                await page.goto(url, { waitUntil: "networkidle", timeout: pageTimeout });

                // Warten bis das Streamlit DOM vorhanden ist
                // Kennzeichnendes Root Element
                await page.waitForSelector('[data-testid="stAppViewContainer"]', { timeout: 15000 });

                // Optional die interne Health Route anfragen
                const health = await page.evaluate(async () => {
                  try {
                    const r = await fetch("/_stcore/health");
                    return `${r.status}`;
                  } catch {
                    return "fetch-failed";
                  }
                });
                console.log(`Health ${base}: ${health}`);

                // Sicherstellen, dass eine Websocket Verbindung versucht wurde
                // Beobachte kurz Netzwerkaktivitaet
                await page.waitForTimeout(4000);

                // Zweiter kurzer Touch auf die Basis
                await page.goto(base + "/", { waitUntil: "domcontentloaded", timeout: pageTimeout });
                await page.waitForTimeout(1500);

                console.log(`OK ${base}`);
              } catch (e) {
                console.log(`WARN ${base}: ${e.message}`);
              } finally {
                await page.close();
              }
            }

            await context.close();
            await browser.close();
          };

          run();
          EOF

      - name: Run wake script
        run: node wake.mjs
